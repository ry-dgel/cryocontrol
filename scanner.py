from typing import Callable
import numpy as np
import numpy.typing as npt
from inspect import signature
from numbers import Number
from warnings import warn
from pathlib import Path
from threading import Thread

class Scanner():
    """Class for running a function with parameters swept over a grid. 
       Allows for snaking of parameters, as well
       as using logarithmic spacing instead of linear. 
       Can also handle saving of results with sweep information.

        Parameters (for __init__)
        ----------
        function : Callable
            The function to be called at each point, must only take in the swept
            parameters as input. i.e. if `x`,`y` are swept, must have signature `f(x,y)`.
            Any other parameters/constants must be defined in the function being passed.
            It can be useful to use lambdas or functools.partial to achieve this.
        centers : list[Number]
            The central values of each parameter sweep.
        spans : list[Number]
            The size of the range to sweep over each parameter.
        steps : list[int]
            How many steps to take along each axis.
        snake : list[int], optional
            A list indexing which axes should be snaked, i.e. the direction of 
            sweep is alternated every time this axis reaches a bound.
            By default []
        log : list[int], optional
            A list indexing which axes should have logarithmic spacing. 
            By default []
        output_dtype : npt.DTypeLike, optional
            The type of output generated by the function run at each point.
            This is used to prealocate the output array. If your function outputs a single
            numeric value at each point, it's much more efficient to precisely indicate the
            return type (e.g. `float`, `int`) here. Otherwise, using `object` is recommended.
            For saving the raw data, only float/int output_dtypes can easily be saved to a .csv, 
            so object will result in .npz numpy array archives being saved. 
            By default object
        labels : list[], optional
            A list of labels to call each axis of the sweep, used for saving the data.
            If None, will label each axis by number, e.g. [1,2,3,...].
            Values passed will be converted to str. 
            By default None.
        init : Callable, optional
            A function to be run once before starting the sweep. Useful for initializing some
            hardware or values. Must take no parameters.
            By default None
        progress : Callable, optional
            A function to be run after getting the results of every step. Useful for monitoring
            the results. Must take 4 parameters:
              * I : int, the current step number.
              * Imax : int, the total number of steps in the sweep.
              * index : tuple[int], the current index along each axis positive position axis.
              * position : tuple[Number], the current positions along each axis.
              * result : npt.DTypeLike, the output of `function` at the current position.
            By default None
        finish : Callable, optional
            A function run once after the sweep finishes. Useful for saving data or gracefully closing
            hardware connections. Must take 2 parameters:
              * results : numpy.ndarray, the full array of results produced during the scan
              * completed : bool, whether the sweep fully completed, or was aborted midway through.
            By default None
    """
    def __init__(self, function : Callable,
                 centers : list[Number], spans: list[Number], steps : list[int],
                 snake : list[int] = [],
                 log : list[int] = [],
                 output_dtype: npt.DTypeLike = object,
                 labels : list[object] = None,
                 init:Callable = lambda *args: None,
                 abort:Callable = lambda *args: False,
                 progress:Callable = lambda *args: None, 
                 finish:Callable= lambda *args: None) -> None:
        """Create a sweeper object, automatically checks that some values are sane.

        Parameters (for __init__)
        ----------
        function : Callable
            The function to be called at each point, must only take in the swept
            parameters as input. i.e. if `x`,`y` are swept, must have signature `f(x,y)`.
            Any other parameters/constants must be defined in the function being passed.
            It can be useful to use lambdas or functools.partial to achieve this.
        centers : list[Number]
            The central values of each parameter sweep.
        spans : list[Number]
            The size of the range to sweep over each parameter.
        steps : list[int]
            How many steps to take along each axis.
        snake : list[int], optional
            A list indexing which axes should be snaked, i.e. the direction of 
            sweep is alternated every time this axis reaches a bound.
            By default []
        log : list[int], optional
            A list indexing which axes should have logarithmic spacing. 
            By default []
        output_dtype : npt.DTypeLike, optional
            The type of output generated by the function run at each point.
            This is used to prealocate the output array. If your function outputs a single
            numeric value at each point, it's much more efficient to precisely indicate the
            return type (e.g. `float`, `int`) here. Otherwise, using `object` is recommended.
            For saving the raw data, only float/int output_dtypes can easily be saved to a .csv, 
            so object will result in .npz numpy array archives being saved. 
            By default object
        labels : list[], optional
            A list of labels to call each axis of the sweep, used for saving the data.
            If None, will label each axis by number, e.g. [1,2,3,...].
            Values passed will be converted to str. 
            By default None.
        init : Callable, optional
            A function to be run once before starting the sweep. Useful for initializing some
            hardware or values. Must take no parameters.
            By default None
        abort: Callable, optional
            A function to be checked after every point, if this function
            returns true, the scan will be interrupted skipping the finish function. 
            Must take 5 parameters:
              * I : int, the current step number.
              * Imax : int, the total number of steps in the sweep.
              * index : tuple[int], the current index along each axis positive position axis.
              * position : tuple[Number], the current positions along each axis.
              * result : npt.DTypeLike, the output of `function` at the current position.
            By default, always returns False
        progress : Callable, optional
            A function to be run after getting the results of every step. Useful for monitoring
            the results. Must take 5 parameters:
              * I : int, the current step number.
              * Imax : int, the total number of steps in the sweep.
              * index : tuple[int], the current index along each axis positive position axis.
              * position : tuple[Number], the current positions along each axis.
              * result : npt.DTypeLike, the output of `function` at the current position.
            By default None
        finish : Callable, optional
            A function run once after the sweep finishes. Useful for saving data or gracefully closing
            hardware connections. Must take 2 parameters:
              * results : numpy.ndarray, the full array of results produced during the scan
              * completed : bool, whether the sweep fully completed, or was aborted midway through.
            By default None
        """

        self._n_params = len(signature(function).parameters)
        if len(centers) != self._n_params:
            raise RuntimeError("Number of centers doesn't match number of function parameters")
        if len(spans) != self._n_params:
            raise RuntimeError("Number of spans doesn't match number of function parameters")
        if len(steps) != self._n_params:
            raise RuntimeError("Number of steps doesn't match number of function parameters")
        if labels is not None and len(labels) != self._n_params:
            raise RuntimeError("Number of labels doesn't match number of function parameters")
        for i in snake:
            if not (0 < i <= self._n_params - 1):
                raise RuntimeError(f"Invalid axis to snake: {i}")
        for i in log:
            if not log <= self._n_params - 1:
                raise RuntimeError(f"Invalid axis to logarithmic {i}")

        # If values of parameters is wrong, and the function doesn't take an arbitrary length *args.
        if len(signature(init).parameters) != 0:
            if list(signature(init).parameters.values())[0].kind != 2:
                raise RuntimeError("Progress function must take no parameters.")
        if len(signature(abort).parameters) != 5:
            msg = "Abort function must take 5 parameters (i, imax, index, pos, result)."
            try:
                if list(signature(abort).parameters.values())[0].kind != 2:
                    raise RuntimeError(msg)
            except IndexError:
                raise RuntimeError(msg)
        if len(signature(progress).parameters) != 5:
            msg = "Progress function must take 5 parameters (i, imax, index, pos, result)."
            try:
                if list(signature(progress).parameters.values())[0].kind != 2:
                    raise RuntimeError(msg)
            except IndexError:
                raise RuntimeError(msg)
        if len(signature(finish).parameters) != 2:
            msg = "Finish function must take 2 parameters (results, completed)."
            try:
                if list(signature(finish).parameters.values())[0].kind != 2:
                    raise RuntimeError(msg)
            except IndexError:
                raise RuntimeError(msg)

        self._func = function

        self._centers = np.atleast_1d(centers)
        self._spans = np.atleast_1d(spans)
        self._steps = np.atleast_1d(steps)
        self._dtype = output_dtype
        self._snake = snake
        self._log = log
        self.labels = [str(label) for label in labels] if labels else [str(i) for i in range(len(steps))]
        self._init_func = init
        self._abort_func = abort
        self._prog_func = progress
        self._finish_func = finish

        self._has_run = False

        self._positions = self._get_positions()

    def _get_positions(self):
        """From the center,span,step lists. Generate the list of every value to be visited.

        Returns
        -------
        positions : list[numpy.ndarray]
            A list where each value is that axis' numpy array of positions to be visisted.
        """
        positions = []
        for i,(center,span,step) in enumerate(zip(self._centers,self._spans,self._steps)):
            if i in self.log:
                position = np.logspace(np.log10(center-span/2),np.log10(center+span/2),step)
            else:
                position = np.linspace(center-span/2,center+span/2,step)
            positions.append(position)
        return positions

    def _get_centers_spans_steps(self):
        """From a list of positions, determine the center, span and number of steps

        Returns
        -------
        centers : list[numpy.ndarray]
            A list where each value is that axis' center position. Calculated as (start+end)/2.
        spans : list[numpy.ndarray]
            A list where each value is that axis' position span. Calculated as (end - start).
        steps : list[numpy.ndarray]
            A list where each value is that axis' number of steps. From length of position array.
        """
        centers = []
        spans = []
        steps = []
        for position in self._positions:
            centers.append((position[0] + position[-1])/2)
            spans.append(position[-1] - position[0])
            steps.append(len(position))
        return centers, spans, steps

    @property
    def positions(self):
        """The positions to be visited along each axis. This list will be used to generate all
           positions when running the scan.

        Returns
        -------
        list[numpy.ndarray]
            A list where each value is that axis' numpy array of positions to be visisted.
        """
        return self._positions

    @positions.setter
    def positions(self, positions : list[npt.ArrayLike]):
        """Set the positions to be visited along each array.

        Parameters
        ----------
        positions : list[npt.ArrayLike[float]]
            A list of arrays of positions, one for each axis. If set this way, 
            the center, span, and steps attributes will automatically be set to match.
            Though this only makes sense if the positions are equally spaced. If that's not the case
            ignore those values as they will not make sense. Must be the same length
            as the number of parameters in the sweep function.
        """
        positions = np.atleast_1d(positions)
        if len(positions) != self._n_params:
            raise RuntimeError("Number of positions doesn't match number of function parameters")
        else:
            self._positions = positions
        self._centers, self._spans, self._steps = self._get_centers_spans_steps()

    @property
    def centers(self):
        """Get the central value of the scan along each axis.

        Returns
        -------
        list[float]
            A list where each value is that axis' center position. If `positions` where set manually
            and are not equally spaced, this value will not necessarily be the one reached halfway
            through the scan.
        """
        return self._centers
    
    @centers.setter
    def centers(self, centers : list[float]):
        """Set the central position of each scan axis. If set this way, the `positions` arrays will
        automatically be update to match the center,span,steps and log settings.

        Parameters
        ----------
        centers : list[float]
            A list where each value is that axis' center position. Must be the same length
            as the number of parameters in the sweep function.
        """
        centers = np.atleast_1d(centers)
        if len(centers) != self._n_params:
            raise RuntimeError("Number of centers doesn't match number of function parameters")
        else:
            self._centers = centers
            self._positions = self._get_positions()

    @property
    def spans(self):
        """Get the central value of the scan along each axis.

        Returns
        -------
        list[float]
            A list where each value is that axis' span.
        """
        return self._spans
    
    @spans.setter
    def spans(self, spans : list[float]):
        """Set the span of each scan axis. If set this way, the `positions` arrays will
        automatically be update to match the center,span,steps and log settings.

        Parameters
        ----------
        spans : list[float]
            A list where each value is that axis' span. Must be the same length
            as the number of parameters in the sweep function.
        """
        spans = np.atleast_1d(spans)
        if len(spans) != self._n_params:
            raise RuntimeError("Number of spans doesn't match number of function parameters")
        else:
            self._spans = spans
            self._positions = self._get_positions()
    
    @property
    def steps(self):
        """Get the number of steps of the scan along each axis.

        Returns
        -------
        list[int]
            A list where each value is that axis' number of steps.
        """
        return self._steps
    
    @steps.setter
    def steps(self, steps : list[int]):
        """Set the span of each scan axis. If set this way, the `positions` arrays will
        automatically be update to match the center,span,steps and log settings.

        Parameters
        ----------
        steps : list[int]
            A list where each value is that axis' number of steps. Must be the same length
            as the number of parameters in the sweep function.
        """
        steps = np.atleast_1d(steps)
        if len(steps) != self._n_params:
            raise RuntimeError("Number of steps doesn't match number of function parameters")
        else:
            self._steps = steps
        self._positions = self._get_positions()

    @property
    def snake(self):
        """Get the list of axes which are set to be snaked.

        Returns
        -------
        list[int]
            A list of axes to be snaked. See `Scanner.__init__` docs for more info. 
        """
        return self._snake

    @snake.setter
    def snake(self, indices : list[int]):
        """Set which axes should be snaked. See `Scanner.__init__` docs for more info.

        Parameters
        ----------
        indices : list[int]
            A list of index values. Index 0 cannot be snaked, as it's only traversed once.
        """
        for i in indices:
            if not (0 < i <= self._n_params - 1):
                raise RuntimeError(f"Invalid axis to snake: {i}")
        self._snake = indices

    @property
    def log(self):
        """Get the list of axes which are set to be swept with logarithmic spacing.

        Returns
        -------
        list[int]
            A list of values indexing which axes to be swept logarithmically.
        """
        return self._log

    @log.setter
    def log(self, indices : list[int]):
        """Set which axes should be swept logarithmically.

        Parameters
        ----------
        indices : list[int]
            A list of index values.
        """
        for i in indices:
            if not i <= self._n_params - 1:
                raise RuntimeError(f"Invalid axis to logarithmic: {i}")
        self._log = indices
        self._positions = self._get_positions()

    def run(self):
        """Run the sweep. Starts by doing some internal initialization to preallocate the
        results array and generate all positions, 
        and then runs the provided initialization function. 
        Then, sweeps through all positions and runs the
        provided sweep function, saving the results, followed by the progress function.
        Once the sweep is completed the provided finish function is run, and finally the results
        array is returned. 

        Returns
        -------
        np.ndarray[npt.DTypeLike]
            The results of running the sweep function at each position.
        """
        Imax = np.prod(self._steps)
        results = np.zeros(self._steps, dtype=self._dtype)
        self.results = results
        self._has_run = True
        positions, indices = self.generate_scan_positions()
        self._prev_positions = self.positions
        
        self._init_func()

        completed = False
        for I,(index,position) in enumerate(zip(zip(*indices),zip(*positions))):
            result = self._func(*position)
            results[index] = result
            if self._abort_func(I,Imax,index,position,result):
                return results
            self._prog_func(I, Imax, index, position, result)
        else:
            completed = True
        
        self._finish_func(results, completed)

        return results

    def run_async(self):
        """Runs the sweep as described in `run()`, but does it in a new thread,
           allowing for asynchronous operation. Since this is just a separate
           thread, you're still blocked from running multiple operations by the
           Global Interpretor Lock, so this should be avoided for super fast
           sweeps. Only returns the thread object which you can await on using,
           `thread.join()`, or check the status with `thread.is_alive()`. To then
           get the results, simply use `scanner.results` once you know the scan is
           done.

           Functions that do their own threading, such as opening a new
           matplotlib window will likely not like this, so avoid running those
           inside the scan.

        Returns
        -------
        threading.Thread
            The thread object in which the scan sweep was run.
        """
        t = Thread(target=self.run)
        t.start()
        return t

    def save_results(self,filename : str, as_npz : bool=False, header:str=""):
        """Saves the results from the most recent running of the sweeper.
        If called before Sweeper.run(), an error will be raised.

        Parameters
        ----------
        filename : str
            The path to the file to be saved, without an extension.
            The path will be checked for an existing file with the same name, in which
            case a number will be appended to avoid conflicts.
        as_npz : bool, optional
            If true the data will be saved as a binary numpy array archive, allowing for the easy
            saving/loading of arbitrary multidimensional data. 
            Otherwise, will attempt to save the data to a csv, 
            however if the data is too complicated, i.e. the output type of the function
            is not a single number, it will have to be saved as an npz.
            By default False
        header : str, optional
            Additional data to be saved with the file. 
            
            In the case of csv output, this will be
            put at the start of the file, before the data. 
            Additionally, for a csv, a line will be added at the start
            indicating how many lines of header are being included.
            With format "n_header_lines = #". It is recommended to avoid
            usual delimiter characters such as ',' '\t', ':' in the header
            as this may confuse text parsing in numpy or pandas for example.

            If saving as npz, this text be included as an additional array named 'header', 
            with no additional line info.
            By default ""
        """
        if isinstance(filename, str):
            filename = Path(filename)
        filename = _safe_file_name(filename)
        if not self._has_run:
            raise RuntimeError("Scan must be run before saving results")

        if self._dtype is object and not as_npz:
            warn("object arrays must be saved as npz, forcing as_npz = True")
            as_npz = True

        results = self.results
        positions = self._prev_positions
        if as_npz:
            np.savez(filename, res=results, 
                               pos=np.array(positions),
                               head=np.array(header))
        
        else:
            with open(filename.with_suffix(".csv"), 'w') as f:
                if header != "" or header is not None:
                    nline = len(header.split('\n')) + 2
                    f.write(f"n_header_lines = {nline}\n")
                    f.write(header)
                    f.write("\n")
                for label in self.labels:
                    f.write(f"{label}, ")
                f.write(f"value\n")
                for nindex, value in np.ndenumerate(results):
                    pos = [positions[i][idx] for i,idx in enumerate(nindex)]
                    for p in pos:
                        f.write(f"{p}, ")
                    f.write(f"{value}\n")

    def generate_scan_positions(self):
        """Generate the full set of scan positions for the scanner, as well
           as the indices of the output array that correspond to the positions.

           TODO: While this works as is, it's not super memory efficient.
           This can probably be handled by a smart iterator.
        Returns
        -------
        list[np.ndarray[Number]]
            The array of positions for every step, for every index.
        list[np.ndarray[Int]]
            The index along each positive position [xmin,...,xmax] array.
            This is need to know where we are in a ndarray when snaking the scan.
        """
        positions = []
        indices = []
        
        for ax in range(self._n_params):
            n_tile = np.prod(self._steps[:ax])
            n_repeat = np.prod(self._steps[ax+1:])
            pos = self._positions[ax]
            idx = np.arange(len(pos),dtype=int)
            if ax in self._snake:
                pos = np.concatenate((pos,np.flip(pos)))
                idx = np.concatenate((idx,np.flip(idx)))
                if odd_tile := n_tile % 2:
                    n_tile -= 1
                n_tile //= 2
                pos = np.tile(pos,n_tile)
                idx = np.tile(idx,n_tile)
                if odd_tile:
                    pos = np.concatenate((pos,self._positions[ax]))
                    idx = np.concatenate((idx,np.arange(len(self._positions[ax]))))
                pos = np.repeat(pos,n_repeat)
                idx = np.repeat(idx,n_repeat)
            else:
                pos = np.tile(pos,n_tile)
                idx = np.tile(idx,n_tile)
            pos = np.repeat(pos, n_repeat)
            idx = np.repeat(idx, n_repeat)
            positions.append(pos)           
            indices.append(idx)

        return positions, indices
    
def _safe_file_name(filename : Path):
    """Check the file path for a file with the same name, if one is found
       append a number to the given filename to avoid conflicts.


    Parameters
    ----------
    filename : Path
        A path object pointing to a file.

    Returns
    -------
    Path
        The same filename with a number added if needed.
    """
    suffix = ""
    if filename.is_file():
        folder = filename.parent
        inc = len(list(folder.glob(f"{filename.stem}*")))
        return folder / f"{filename.stem}{inc}{filename.suffix}"
    else:
        return filename

